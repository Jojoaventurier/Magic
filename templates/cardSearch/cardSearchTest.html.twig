{% extends 'base.html.twig' %}

{% block title %}Search Cards{% endblock %}

{% block body %}

<main>
    <div class="gradient-bg flex flex-col flex-wrap w-full items-center justify-end space-y-6 pt-20 pb-10">

        <div class="inline-flex space-x-8 w-full justify-center items-center averia-serif-libre-light">
            <div class="flex w-72 opacity-60">
                <img src="{{ asset('search-imgs/compulsive.jpg') }}" class=" rounded-xl" id="placeholder1" style="mask-image: linear-gradient(to top, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%), 
                linear-gradient(to bottom, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%), 
                linear-gradient(to left, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%), 
                linear-gradient(to right, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%);
mask-composite: intersect;">
            </div>

            <div class="space-y-2 border border-white p-4 rounded">
                <div class="space-y-2 border border-white p-4 rounded">

                    <h1 class="px-6 text-3xl font-medium text-white w-prose">Recherche de cartes</h1>
                    <p class="px-6 text-white italic text-sm">Utilisez les filtres ci-dessous pour affiner votre recherche.</p>
                </div>
            </div>
            <div class="flex w-72 opacity-60">
                <img src="{{ asset('search-imgs/frantic.jpg') }}" class=" rounded-xl" id="placeholder2" style="mask-image: linear-gradient(to top, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%), 
                linear-gradient(to bottom, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%), 
                linear-gradient(to left, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%), 
                linear-gradient(to right, rgba(0, 0, 0, 0) 1%, rgba(0, 0, 0, 1) 25%);
mask-composite: intersect;">
            </div>
        </div>
    </div>

<div class="sticky top-4 z-10 bg-white mx-auto pt-4 mt-4 mb-1">
    <div class="flex space-x-8 justify-center items-center">

        {% set active = 'text-sm bg-red-800 text-white px-4 py-2 rounded hover:bg-red-900 shadow-md cursor-pointer hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)]duration-300' %}
        {% set inactive = 'text-sm bg-white text-red-700 px-4 py-2 rounded hover:bg-red-900 hover:text-white shadow-md cursor-pointer hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300' %}

        <div class="flex flex-col space-y-4">
            <!-- Sélecteur pour filtrer les cartes par type -->
            <select id="typeSelect" 
            class="border border-red-700 text-sm rounded px-4 py-2 focus:ring-2 focus:outline-none outline-none hover:bg-gray-100 h-10 hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] shadow duration-300">
                <option value="">Tous les types</option> <!-- Option par défaut qui affiche tous les types de cartes -->
                <option value="legendary">Légendaire</option> <!--filtrer les cartes par type légendaire-->
                <option value="creature">Creature</option> <!--filtrer les cartes par type créature etc.-->
                <option value="artifact">Artefact</option>
                <option value="enchantment">Enchantement</option>
                <option value="battle">Bataille</option>
                <option value="instant">Ephémère</option>
                <option value="sorcery">Rituel</option>
                <option value="land">Terrain</option>
                <option value="planeswalker">Planeswalker</option>
                <option value="saga">Saga</option>
            </select>

            <select id="subtypeSelect" class="border border-red-700 text-sm rounded px-4 py-2 focus:ring-2 focus:outline-none outline-none hover:bg-gray-100 h-10 hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] shadow duration-300">
                <option value="">Tous les sous-types</option>
                <!-- Options sont peuplées dynamiquement en fonction des résultats de la recherche -->
            </select>
        </div>

        <div class="border px-4 py-2 border-red-700 rounded hover:bg-gray-100 hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] shadow duration-300">
            <!-- Conteneur pour les options de filtrage par couleur -->
            <div class="px-2 space-x-2">
                <!-- Option radio pour inclure exactement une couleur -->
                <label class="text-sm italic text-gray-700 hover:underline">
                    <input name="color" type="radio" checked value="c:" id="colorOnly">
                    Incluant exactement
                </label>
                <!-- Option radio pour inclure séparément une couleur -->
                <label class="text-sm italic text-gray-700 hover:underline">
                    <input name="color" type="radio" value="ci:" id="colorIncluding">
                    Incluant séparément
                </label>
            </div>

            <!-- Sélecteur pour choisir les couleurs avec des cases à cocher -->
            <div id="colorSelect" class="flex flex-wrap justify-center space-x-4 py-2">
                <!-- Cases à cocher pour chaque couleur de mana -->
                <label><input type="checkbox" value="W"><img class="w-5" src="/icons/mana/W.webp"></label>
                <label><input type="checkbox" value="R"><img class="w-5" src="/icons/mana/R.webp"></label>
                <label><input type="checkbox" value="G"><img class="w-5" src="/icons/mana/G.webp"></label>
                <label><input type="checkbox" value="B"><img class="w-5" src="/icons/mana/B.webp"></label>
                <label><input type="checkbox" value="U"><img class="w-5" src="/icons/mana/U.webp"></label>
                <!-- Case à cocher pour le mana incolore -->
                <label><input id="colorless" type="checkbox" value="C"><img class="w-5" src="https://svgs.scryfall.io/card-symbols/C.svg" alt="Colorless Mana Symbol"></label>               
            </div>
        </div>
        <div class="flex flex-col space-y-4">
        
            <div class="border border-red-700 text-sm rounded px-4 py-2 focus:ring-2 focus:outline-none outline-none hover:bg-gray-100 hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] shadow duration-300">
                <!-- Label pour le sélecteur de coût de mana -->
                <label for="cmcSelect">Filtrer par coût de mana :</label>

                <!-- Sélecteur pour choisir le coût de mana avec différentes options -->
                <select id="cmcSelect" class="text-sm rounded focus:ring-2 focus:outline-none outline-none text-center px-2 space-y-1">
                    <!-- Option par défaut sans filtre appliqué -->
                    <option class="italic" value="">Aucun filtre</option>
                    <!-- Options pour les différents coûts de mana de 0 à 20 -->
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="13">13</option>
                    <option value="14">14</option>
                    <option value="15">15</option>
                    <option value="16">16</option>
                    <option value="17">17</option>
                    <option value="18">18</option>
                    <option value="20">20</option>
                </select>
            </div>
            <div class="flex flex-col">
                <!-- label pour le champ de recherche de set/extension -->
                <label class="text-sm">
                    Set / Extension <span class="text-xs italic"> exemple : fdn</span>
                </label>

                <!-- Champ de saisie pour rechercher un set/extension -->
                <!-- Si le token de recherche est 'set', préremplir le champ avec le paramètre de recherche -->
                <input 
                    id="setSearch" 
                    type="text" 
                    class="border border-red-700 text-sm rounded px-4 py-2 focus:ring-2 focus:outline-none outline-none hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] shadow duration-300"
                    {% if searchToken is same as 'set' %}
                        value="{{ searchParameter }}"    
                    {% endif %}
                >
            </div>
        </div>

        <div class="flex flex-col flex-wrap">
            <!-- Label et case à cocher pour rechercher par nom d'artiste -->
            <label class="text-sm hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300 px-4 py-2 rounded-lg">
                <!-- Si le token de recherche est 'artist', la case à cocher est cochée par défaut -->
                <input id='artistSearch' type="checkbox"
                {% if searchToken is same as 'artist' %}
                    checked
                {% endif %}
                > Recherche par nom d'artiste
            </label> 
            
            <!-- Étiquette et case à cocher pour afficher toutes les versions des cartes -->
            <label class="text-sm hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300 px-4 py-2 rounded-lg">
                <input id='uniquePrints' type="checkbox">
                Afficher toutes les versions des cartes
            </label>
            
            <!-- Étiquette et case à cocher pour inclure les extras (jetons, plans, etc.) -->
            <label class="text-sm hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300 px-4 py-2 rounded-lg">
                <input id='includeExtras' type="checkbox">
                Inclure les Extras (jetons, plans...)
            </label>
        </div>

        <div class="flex flex-col items-center justify-center space-y-4">
            <button id="hideFilters" class="h-10 border border-bg-red-400 text-red-700 hover:bg-red-800 hover:text-white hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300 px-4 py-2 rounded shadow-md text-sm">Masquer les filtres</button>
            <button id="reinitializeButton" class="h-10 border border-bg-red-400 text-red-700 hover:bg-red-800 hover:text-white hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300 px-4 py-2 rounded shadow-md text-sm">Réinitialiser les filtres</button>
        </div>                             
    </div>
    <div class="flex flex-col justify-center items-center z-30 ">
        <div class="flex justify-evenly rounded-md">
            <!-- Conteneur principal pour les options de rareté -->
            <div class="inline-flex space-x-4 p-2 bg-white rounded-md">
                <!-- Option pour afficher toutes les cartes, option par défaut-->
                <div id="rarityAll" class="{{ active }}">Toutes</div>
                <!-- Option pour afficher uniquement les cartes mythiques-->
                <div id="rarityMythic" class="{{ inactive }}">Mythiques</div>
                <!-- Option pour afficher uniquement les cartes rares -->
                <div id="rarityRare" class="{{ inactive }}">Rares</div>
                <!-- Option pour afficher uniquement les cartes non communes -->
                <div id="rarityUncommon" class="{{ inactive }}">Non communes</div>
                <!-- Option pour afficher uniquement les cartes communes -->
                <div id="rarityCommon" class="{{ inactive }}">Communes</div>
            </div>

            <div class="inline-flex justify-center space-x-3 p-2 bg-white rounded-md">
                <!-- Champ de recherche pour entrer un terme -->
                <input type="text" id="searchInput" class="border border-red-700 bg-white text-sm rounded px-4 py-2 w-96 focus:ring-2 focus:outline-none outline-none hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] shadow duration-300" 
                {% if searchToken is same as 'artist' or searchToken is same as 'active' %}
                {# Remplit le champ avec le paramètre de recherche si le token de recherche est 'artist' ou 'active' #}
                    value="{{ searchParameter }}" 
                {% endif %}  
                placeholder="Entrez un terme de recherche..."> <!-- Indique à l'utilisateur ce qu'il doit entrer -->
            
                <!-- Icône pour effacer le texte du champ de recherche -->
                <img id="eraser" class="w-10 border rounded hover:border-red-800 transition duration-300 hover:shadow-md bg-white" src="https://img.icons8.com/carbon-copy/100/erase.png" alt="eraser to clear text"/>
            
                <!-- Bouton pour lancer la recherche -->
                <button id="searchStart" class="h-10 bg-white text-red-700 px-4 py-2 rounded hover:bg-red-800 hover:text-white hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] border border-red-700 duration-300 text-sm">Rechercher</button>
            
                <!-- Bouton pour réinitialiser le champ de recherche -->
                <button id="resetSearch" class="h-10 px-4 py-2 text-xs rounded bg-white border-red-700 text-red-700 hover:bg-red-800 hover:text-white hover:shadow-[0px_10px_20px_0px_rgba(0,_0,_0,_0.15)] duration-300">RESET</button>
            </div>

        </div>
        <div id="count" class="flex justify-center hidden">
            <p class="text-grey-600 italic text-xs p-2 bg-white rounded-md"><span id="totalCards"></span> cartes trouvées</p>
        </div>
    </div>
</div>
    
    <div class="w-full flex justify-center pt-12 bg-gradient-purple h-screen">
        <!-- Conteneur principal centré pour les cartes -->
        <div class="flex flex-col flex-wrap max-w-4/5 w-4/5 px-10 bg-gradient-purple">
            <!-- Zone où les cartes seront affichées -->
            <div id="cardBoard" class="w-full flex justify-center">
                <!-- Liste des cartes, remplie dynamiquement avec les images récupérées de l'API Scryfall -->
                <div id="cardList" class="flex flex-wrap justify-center"></div>
            </div>
        </div>
    </div>

    <!-- Placeholder for no cards found message -->
    <div id="noCardsMessage" class="hidden text-center text-red-500 mt-4">
        Aucune carte trouvée avec les filtres sélectionnés.
    </div>
</main>

{% block javascripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    console.log('Page chargée et script exécuté!');

    const cardList = document.querySelector("#cardList");
    const count = document.getElementById('count');
    const eraser = document.getElementById('eraser');
    
    // Ajouter un écouteur d'événements pour le clic sur l'effaceur
    eraser.addEventListener('click', () => {
        // Effacer la valeur du champ de saisie lorsque l'effaceur est cliqué
        searchInput.value = '';
    });

// Sélectionne l'élément d'entrée pour la barre de recherche
const searchInput = document.getElementById('searchInput');
// Sélectionne le bouton pour démarrer la recherche
const searchStart = document.getElementById('searchStart');

// Sélectionne l'élément qui affiche un message si aucune carte n'est trouvée
const noCardsMessage = document.getElementById('noCardsMessage');

// Sélectionne l'élément du menu déroulant pour le type de carte
const typeSelect = document.getElementById('typeSelect');
// Sélectionne toutes les cases à cocher pour la sélection de couleurs
const colorCheckboxes = document.querySelectorAll('#colorSelect input[type="checkbox"]');
// Sélectionne l'élément du menu déroulant pour le sous-type de carte
const subtypeSelect = document.getElementById('subtypeSelect');
// Sélectionne la case à cocher pour activer la recherche d'artiste
const artistSearch = document.getElementById('artistSearch');
// Sélectionne la case à cocher pour afficher uniquement les impressions uniques des cartes
const uniquePrints = document.getElementById('uniquePrints');
// Sélectionne la case à cocher pour inclure des cartes supplémentaires (extras) dans la recherche
const includeExtras = document.getElementById('includeExtras');
// Sélectionne l'élément d'entrée pour filtrer par set de cartes
const setInput = document.getElementById('setSearch');
// Sélectionne la case à cocher pour correspondance exacte des couleurs sélectionnées
const colorOnly = document.getElementById('colorOnly');
// Sélectionne la case à cocher pour correspondance inclusive des couleurs sélectionnées
const colorIncluding = document.getElementById('colorIncluding');
// Sélectionne la case à cocher pour exclure toutes les cartes colorées (incolore)
const colorless = document.getElementById('colorless');
// Sélectionne l'élément du menu déroulant pour filtrer les cartes par coût de mana converti (cmc)
const cmcSelect = document.getElementById('cmcSelect');
// Sélectionne le bouton pour réinitialiser les filtres de recherche
const reinitializeButton = document.getElementById('reinitializeButton');
// Sélectionne le bouton pour réinitialiser complètement la recherche
const resetSearch = document.getElementById('resetSearch');
// Objet contenant les boutons de rareté (toutes, mythique, rare, inhabituelle, commune)
const rarityButtons = {
    all: document.getElementById('rarityAll'),        // Bouton pour sélectionner toutes les raretés
    mythic: document.getElementById('rarityMythic'),  // Bouton pour sélectionner les cartes mythiques
    rare: document.getElementById('rarityRare'),      // Bouton pour sélectionner les cartes rares
    uncommon: document.getElementById('rarityUncommon'), // Bouton pour sélectionner les cartes inhabituelles
    common: document.getElementById('rarityCommon')   // Bouton pour sélectionner les cartes communes
};
// Variable pour stocker la rareté sélectionnée par l'utilisateur (initialement vide)
let selectedRarity = '';

    function updateFetchUrl() {

        // Récupération de la valeur de recherche saisie dans le champ de recherche et supprime les espaces inutiles
        let searchTerm = searchInput.value.trim();

        // Initialisation de la chaîne de requête avec le terme de recherche si fourni
        let query = searchTerm ? `${searchTerm}` : "";
    
        // Utilisation d'une autre chaîne de requête vide pour certaines recherches (ex : artiste)
        let emptyQuery = '';
    
        // Récupération des valeurs sélectionnées dans les menus   déroulants et les champs de saisie
        // pour le type
        let type = typeSelect.value;
        // pour le sous-type
        let subtype = subtypeSelect.value;
        // pour le champs de saisie d'une extension
        let set = setInput.value;
        // pour le coût de mana converti (cmc)
        let selectedCMC = cmcSelect.value;
        //Récupération des couleurs sélectionnées (cases à cocher), filtrées pour ne garder que celles qui sont cochées
        // Transformation de la liste des valeurs en une chaîne de caractères séparée par des virgules
        let selectedColors = Array.from(colorCheckboxes)
            .filter(checkbox => checkbox.checked)
            .map(checkbox => checkbox.value)
            .join(',');
    
        // Si un set est sélectionné, ajout du filtre de set à la requête
        if (set) {
            query += `+set:${set}`;
        }
        // Si des couleurs sont sélectionnées, traitement des différentes options de couleurs
        if (selectedColors) {
            // Si la case "incolore" est cochée, exclure toutes les couleurs
            if (colorless.checked) {
                query += `+-c:W+-c:U+-c:B+-c:R+-c:G`;  // Exclut les couleurs : Blanc, Bleu, Noir, Rouge, Vert
                emptyQuery += `+-c:W+-c:U+-c:B+-c:R+-c:G`;
            } 
            // Si l'option "Exact color match" est cochée, ajouter un filtre de correspondance exacte sur les couleurs sélectionnées
            else if (colorOnly.checked) {
                query += `+color=${selectedColors}`;  // Correspondance exacte avec les couleurs sélectionnées
                emptyQuery += `+color=${selectedColors}`;
            } 
            // Si l'option "Inclusive color match" est cochée, inclure toutes les cartes contenant au moins l'une des  couleurs sélectionnées
            else if (colorIncluding.checked) {
                query += `+ci:${selectedColors}`;  // Correspondance inclusive
                emptyQuery += `+ci:${selectedColors}`;
            }
        }
        // Si un coût de mana converti est sélectionné, ajout du filtre de cmc à la requête
        if (selectedCMC) {
            query += `+cmc=${selectedCMC}`;
            emptyQuery += `+cmc=${selectedCMC}`;
        }
        // Si un type est sélectionné, ajout du filtre de type à la requête principale et à la requête vide
        if (type) {
            query += `+type:${type}`;
            emptyQuery += `+type:${type}`;
        }
        // Si un sous-type est sélectionné, ajout du filtre de sous-type à la requête
        if (subtype) {
            query += `+type:${subtype}`;
            emptyQuery += `+type:${subtype}`;
        }
        // Si une rareté est sélectionnée, ajout du filtre de rareté à la requête
        if (selectedRarity) {
            query += `+rarity:${selectedRarity}`;
            emptyQuery += `+rarity:${selectedRarity}`;
        }
    
        // Si "uniquePrints" est coché et "includeExtras" non coché, ajouter les variations uniques à la requête
        if (uniquePrints.checked && includeExtras.checked == false) {
            return `https://api.scryfall.com/cards/search?include_variations=true&order=dir&unique=prints&q=${query}`;
        }
    
        // Si "includeExtras" est coché et "uniquePrints" non coché, inclure les cartes supplémentaires dans la requête
        if (includeExtras.checked && uniquePrints.checked == false) {
            return `https://api.scryfall.com/cards/search?include_extras=true&order=dir&q=${query}`;
        }
    
        // Si les deux "uniquePrints" et "includeExtras" sont cochés, inclure à la fois les extras et les variations   uniques
        if (uniquePrints.checked && includeExtras.checked) {
            return `https://api.scryfall.com/cards/search?include_extras=true&include_variations=true&order=set&unique=prints&q=${query}`;
        }
    
        // Si l'utilisateur effectue une recherche d'artiste, construire une requête spécifique pour cela
        if (artistSearch.checked) {
            // Si le nom de l'artiste contient des espaces, on l'entoure de guillemets (->string)
            let artistQuery = searchTerm.includes(' ') ? `"${searchTerm}"` : searchTerm;
            return `https://api.scryfall.com/cards/search?order=dir&q=artist:${artistQuery}${emptyQuery}`;
        }

        // Par défaut, retourner la requête avec tous les filtres appliqués
        return `https://api.scryfall.com/cards/search?order=dir&q=${query}`;
    }

     //return `https://api.scryfall.com/cards/search?include_extras=true&include_variations=true&order=dir&unique=prints&q=name:${query}`;

    function fetchCards() {
        // Appelle « updateFetchUrl() » pour obtenir l'URL mise à jour en fonction des paramètres de recherche choisis par l'utilisateur
        let url = updateFetchUrl();
        // Lance une requête de récupération (fetch) avec l'URL obtenue ci-dessus. 'fetch' est utilisé pour effectuer la requête HTTP vers l'API Scryfall 
        fetch(url)
            //la réponse de l'appel à fetch sera convertie en objet JSON pour être utilisée dans la suite du code
            .then(response => response.json())
            // Une fois les données JSON obtenues, elles sont transmises au bloc '.then()' suivant  pour être traitées.
            .then(data => {

                // Sélectionne l'élément contenant la liste des cartes (cardList)
                const myNode = document.getElementById("cardList");
                
                // Si l'élément cardList existe, on supprime tous ses enfants 
                // (efface la liste existante)
                if (myNode) {
                    while (myNode.firstChild) {
                        myNode.removeChild(myNode.lastChild);
                    }
                }
            
                // Vérifie que la réponse 'data' contient un tableau de cartes
                if (data.data && Array.isArray(data.data)) {
                    
                    // Si le tableau de données n'est pas vide, on continue
                    if (data.data.length > 0) {
                        console.log(data.data); // Affiche les données des cartes dans la console pour vérification
            
                        // Met à jour le nombre total de cartes trouvées, basé sur la propriété 'total_cards'
                        totalCards.innerHTML = data.total_cards || data.data.length;
            
                        // Cache le message "Aucune carte trouvée" si des cartes sont présentes
                        noCardsMessage.classList.add('hidden');  
            
                        // Crée un ensemble (Set) pour stocker les sous-types uniques de cartes
                        const subtypes = new Set();
                        
                        // Parcourt chaque carte retournée par la recherche
                        data.data.forEach(card => {
            
                            // Vérifie si la carte possède une ligne de type (type_line)
                            if(card.type_line) {
                                
                                // Si la ligne de type contient un tiret (indiquant un sous-type), on la traite
                                if (card.type_line.includes('—')) {
                                    
                                    // Sépare la ligne de type en deux parties : le type principal et les sous-types
                                    const parts = card.type_line.split('—');
                                    
                                    // Crée un tableau des sous-types en supprimant les espaces inutiles
                                    const subtypesArray = parts[1].trim().split(' ');
            
                                    // Ajoute chaque sous-type au Set (en évitant les doublons)
                                    subtypesArray.forEach(subtype => subtypes.add(subtype));
                                }
                            }
                        });
            
                        // Réinitialise le menu déroulant des sous-types avec une option par défaut
                        subtypeSelect.innerHTML = '<option value="">Tous les sous-types</option>';
                        
                        // Ajoute chaque sous-type unique trouvé dans le menu déroulant des sous-types
                        subtypes.forEach(subtype => {
                            const option = document.createElement('option'); // Crée une nouvelle option
                            option.value = subtype.toLowerCase();            // Définit la valeur en minuscule
                            option.textContent = subtype;                    // Définit le texte de l'option
                            subtypeSelect.appendChild(option);               // Ajoute l'option au menu déroulant
                        });

            data.data.forEach(card => {
                let displayCard; // Déclare une variable pour stocker la carte à afficher
                
                // Vérifie si l'objet 'card' a une image normale
                if (card.image_uris && card.image_uris.normal) {
                    displayCard = new Image(250, 350); // Crée un nouvel objet Image avec une taille de 250x350 pixels
                    displayCard.src = card.image_uris.normal; // Définit la source de l'image à l'URL de l'image normale
                    displayCard.id = card.id; // Définit l'ID de l'image en utilisant l'ID de la carte
                    displayCard.classList.add('singleCard', 'p-1', 'transform', 'rounded-xl', 'shadow-xl', 'transition', 'duration-300', 'hover:scale-105', 'mt-1'); // Ajoute des classes CSS pour le style
                } 
                // Vérifie si la carte a des faces (cartes double face) et si la première face a une image normale
                else if (card.card_faces[0]['image_uris'] && card.card_faces[0]['image_uris']['normal']) {
                    displayCard = new Image(250, 350); // Crée une nouvelle image pour la carte double face
                    displayCard.src = card.card_faces[0]['image_uris']['normal']; // Définit la source de l'image de la première face
                    displayCard.id = card.id; // Définit l'ID de l'image en utilisant l'ID de la carte
                    displayCard.classList.add('singleCard', 'p-1', 'transform', 'rounded-xl', 'shadow-xl', 'transition', 'duration-300', 'hover:scale-105', 'mt-1'); // Ajoute des classes CSS pour le style
                }

                // Prépare l'URL pour la page de détail de la carte en remplaçant un identifiant fictif
                var cardDetailUrl = "{{ path('app_card_detail', {'cardId': 'REPLACE_CARD_ID' })}}";
                let link = document.createElement("a"); // Crée un nouvel élément de lien (anchor)
                let url = cardDetailUrl.replace('REPLACE_CARD_ID', card.id); // Remplace l'identifiant fictif par l'identifiant réel de la carte
                link.href = url; // Définit l'attribut href du lien à l'URL de détail de la carte

                link.appendChild(displayCard); // Ajoute l'image de la carte comme enfant du lien
                cardList.appendChild(link); // Ajoute le lien (et l'image de la carte) à la liste des cartes affichées
                count.classList.remove('hidden'); // Affiche l'élément qui contient le compte des cartes
            });

            // Si aucune carte n'est trouvée
            } else {
                setName.innerHTML = "Set non trouvé"; // Affiche un message indiquant que l'ensemble n'a pas été trouvé
                noCardsMessage.classList.remove('hidden'); // Affiche le message "Aucune carte trouvée"
            }

            // Si la réponse de l'API ne contient pas un tableau de cartes
            } else {
                console.error('Erreur: la réponse de l\'API ne contient pas un tableau de cartes dans "data"'); //Affiche une erreur dans la console
                noCardsMessage.classList.remove('hidden'); // Affiche le message "Aucune carte trouvée" en cas d'erreur
            }
            })
            .catch(error => {
                console.error('Erreur:', error); // Affiche l'erreur dans la console
                noCardsMessage.classList.remove('hidden'); // Affiche le message "Aucune carte trouvée" en cas d'erreur
            });
        }

// searchInput.addEventListener('input', fetchCards); // Cette ligne est commentée, elle permettrait d'appeler fetchCards à chaque saisie dans le champ de recherche.

searchStart.addEventListener('click', fetchCards); // Ajoute un écouteur d'événement 'click' sur le bouton de recherche pour       déclencher la fonction fetchCards

// Ajoute un écouteur d'événement 'change' pour chaque case à cocher de sélection de couleur pour déclencher fetchCards lorsque l'état d'une case change.
Array.from(colorCheckboxes).forEach(checkbox => {
    checkbox.addEventListener('change', fetchCards);
});

// Ajoute des écouteurs d'événements 'change' sur plusieurs filtres de recherche (couleurs, types, artiste, CMC, impressions      uniques, et extras) pour déclencher fetchCards à chaque modification.
colorOnly.addEventListener('change', fetchCards); 
colorIncluding.addEventListener('change', fetchCards); 
colorless.addEventListener('change', fetchCards); 
typeSelect.addEventListener('change', fetchCards);
subtypeSelect.addEventListener('change', fetchCards); 
artistSearch.addEventListener('change', fetchCards); 
cmcSelect.addEventListener('change', fetchCards); 
uniquePrints.addEventListener('change', fetchCards); 
includeExtras.addEventListener('change', fetchCards); 

// Ajoute des écouteurs d'événements 'click' sur chaque bouton de rareté (tous, mythique, rare, peu commune, commune).
Object.keys(rarityButtons).forEach(key => {

    // Lors du clic sur un bouton de rareté, met à jour 'selectedRarity' en fonction du bouton cliqué.
    rarityButtons[key].addEventListener('click', function() {
        selectedRarity = key === 'all' ? '' : key;  // Si le bouton "Tous" est cliqué, réinitialise la rareté sélectionnée.

        // Met à jour la classe CSS de chaque bouton pour indiquer visuellement quel bouton est actif.
        Object.keys(rarityButtons).forEach(innerKey => {
            rarityButtons[innerKey].className = key === innerKey ? '{{ active }}' : '{{ inactive }}';  // Active le bouton cliqué et désactive les autres.
        });

        // Rafraîchit la liste des cartes en fonction de la rareté sélectionnée.
        fetchCards();
    });
});

// Ajoute un écouteur d'événement 'click' sur le bouton de réinitialisation.
reinitializeButton.addEventListener('click', function() {
    // Réinitialise les valeurs des champs de recherche et des sélecteurs.
    typeSelect.selectedIndex = 0; // Réinitialise le sélecteur de type au premier élément
    subtypeSelect.selectedIndex = 0; // Réinitialise le sélecteur de sous-type au premier élément
    cmcSelect.selectedIndex = 0; // Réinitialise le sélecteur CMC au premier élément
    artistSearch.checked = false; // Décoche la case pour la recherche par artiste
    uniquePrints.checked = false; // Décoche la case des impressions uniques
    includeExtras.checked = false; // Décoche la case des cartes supplémentaires
    setInput.value = ''; // Vide le champ de recherche de set

    // Réinitialise toutes les cases à cocher de sélection de couleur.
    Array.from(colorCheckboxes).forEach(checkbox => checkbox.checked = false);
    colorOnly.checked = true; // Active l'option 'colorOnly' par défaut

    // Réinitialise la sélection de rareté.
    selectedRarity = ''; // Réinitialise la rareté sélectionnée
    rarityButtons.all.className = '{{ active }}'; // Définit le bouton de rareté 'toutes' comme actif
    rarityButtons.mythic.className = '{{ inactive }}'; // Définit le bouton de rareté 'mythique' comme inactif
    rarityButtons.rare.className = '{{ inactive }}'; // Définit le bouton de rareté 'rare' comme inactif
    rarityButtons.uncommon.className = '{{ inactive }}'; // Définit le bouton de rareté 'peu commune' comme inactif
    rarityButtons.common.className = '{{ inactive }}'; // Définit le bouton de rareté 'commune' comme inactif

    // Cache le message indiquant qu'aucune carte n'a été trouvée.
    noCardsMessage.classList.add('hidden');
    count.classList.add('hidden');
    // Appelle fetchCards pour relancer la recherche avec les paramètres réinitialisés.
    fetchCards();
});

// Ajoute un écouteur d'événement sur le bouton "Réinitialiser la recherche".
resetSearch.addEventListener('click', function() {

    // Réinitialise les champs de saisie de texte (terme de recherche et set).
    searchInput.value = '';
    setInput.value = '';

    // Réinitialise les listes déroulantes (type, sous-type, CMC) à leur première option (valeur par défaut).
    typeSelect.selectedIndex = 0;
    subtypeSelect.selectedIndex = 0;
    cmcSelect.selectedIndex = 0;

    // Décoche toutes les cases à cocher (artiste, versions uniques, extras).
    artistSearch.checked = false;
    uniquePrints.checked = false;
    includeExtras.checked = false;

    // Décoche toutes les cases de couleur et coche par défaut l'option "Incluant exactement".
    Array.from(colorCheckboxes).forEach(checkbox => checkbox.checked = false);
    colorOnly.checked = true;  // Par défaut, on inclut exactement les couleurs sélectionnées.

    // Réinitialise la sélection de rareté (active "Tous" et désactive les autres).
    selectedRarity = '';
    rarityButtons.all.className = '{{ active }}';
    rarityButtons.mythic.className = '{{ inactive }}';
    rarityButtons.rare.className = '{{ inactive }}';
    rarityButtons.uncommon.className = '{{ inactive }}';
    rarityButtons.common.className = '{{ inactive }}';

    // Masque le message "Aucune carte trouvée" s'il était visible.
    noCardsMessage.classList.add('hidden');

    // Masque l'affichage du nombre de cartes.
    count.classList.add('hidden');

    // Supprime toutes les cartes affichées précédemment de la liste.
    const myNode = document.getElementById("cardList");
    if (myNode) {
        while (myNode.firstChild) {
            myNode.removeChild(myNode.lastChild);  // Supprime chaque enfant du nœud un par un.
        }
    }
});

// Dans le cas d'une redirection depuis une extension ou depuis le lien sur le détail d'une carte pour la recherche par artistes
// Si la page est chargée avec une valeur dans la barre de recherche, une recherche est lancée automatiquement
if (searchInput.value) {
    fetchCards(); // Initial fetch when page loads if there is a search parameter given
}
// Idem si une information de set est remplie au chargement de la page
if (setInput.value) {
    fetchCards();
}
});
</script>
{% endblock %}
{% endblock %}

